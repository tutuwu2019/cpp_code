# 滑动窗口
> 最开始接触 滑动窗口  这个概念还是在学计算机网络。后面渐渐的有接触了这方面的算法

关键词：滑动窗口、正整数

现在就简单的讲讲 和 滑动窗口相关的算法

## 滑动窗口算法

1695. 删除子数组的最大得分
> 一个正整数数组，删除一个含有 若干不同元素的 字数组。删除子数组的得分是子数组各元素之和。返回值删除一个字数组可获得的最大得分。
> > 翻译一下，就是找个数组，要求数组得分最大，且这个数组没有重复元素。最后返回得分。（虽然讲着说会删掉）

用滑动窗口的思想，就是大遍历右边界，然后从右边界开始从右往左遍历左边界。遍历左边界的条件  是否已经记录过。


```c++
int solution(std::vector<int> nums){
  int n = nums.size();
  unordered_map<int, bool> has(n + 1);
  int ans = 0, s = 0, lsft = 0;
  for(auto& x : nums){
    while(has[left])){
      has[nums[left]] = false;
      s -= nums[left];
      left++;
    }
    has[x] = true;
    s += nums[x];
    ans = max(ans, s);
  }
  return ans;
}

```

3. 无重复字符的最长字串
> 给定一个字符串，找出不包含重复字符串的 最长字串的长度

```c++
int solution(std::string s){
  int n = s.size(), left = 0, right = 0;
  int ans = 0;
unordered_map<char , int> cnt(n + 1);
  for(auto& x : s){
    cnt[x]++;
    while(cnt[x]>0}{      //   这里暗流了一个点，就是当遍历重复元素，那必然是在 left 处重复了。 
      cnt[left]--;
      left++;
    }
    
    ans = max(ans, x - left + 1);
  }
  return ans;
}

```

209. 长度最小的子数组
> 给定一个含有 n 个正整数的数组和 一个正整数 target。找出该数组种满足大于等于 target 的长度最小的子数组，并返回其长度，如果不存在符合条件的子数组则返回0

左边界变化的条件是什么呢？

```c++
int solution(int target, vector<int>& nums){
  int n = nums.size();
  int left = 0;
  int s = 0, ans = 2*n;
  for(int right = 0; right < n; right++){
    s += nums[right];
    while(s - nums[left] >= target){
      s -= nums[left];
      left++;
    }
    if( s>= target){
      ans = min(ans, right - left + 1);
    }
  return ans <= n : ans : 0;

}
```
713. 乘积小于 k 的子数组
> 提供一个整数数组和一个整数k，返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。

```c++
int solution(int k, vector<int>& nums){
//  边界问题
  if(k <= 1){
    return 0;
  }

  int n = nums.size();
  int ans = 0, s = 1;
  int left = 0;
  for(int right = 0; right < n; right++){
    s *= nums[right];
    while(s >= k){
      s /= nums[left];
      left++;
    }
  ans += right - left + 1;
  }
  return ans;
}

```

