# redis 源码分析


## 流程图

1. Redis 6.0 多线程处理流程图
```mermaid
graph TD
    A[多个客户端请求 Sockets] --> B{主线程 Event Loop}
    B -->|1. 监听就绪事件| C[将就绪客户端分配给 IO 线程组]
    
    subgraph IO_Threads [IO 线程池 - 并行处理]
        D1[IO 线程 1]
        D2[IO 线程 2]
        D3[IO 线程 n]
    end
    
    C --> D1 & D2 & D3
    D1 & D2 & D3 -->|2. 读取 Socket 数据并解析为命令| E{主线程忙等待/同步}
    
    E -->|3. 串行执行命令| F[主线程操作内存 Data]
    F -->|4. 生成响应数据| G[将客户端再次分配给 IO 线程组]
    
    G --> D1 & D2 & D3
    D1 & D2 & D3 -->|5. 将响应写回 Socket| H[完成请求]

```

2. 多线程协作时序图
```mermaid
sequenceDiagram
    participant Clients as 多个客户端
    participant Main as 主线程 (Main Thread)
    participant IOs as IO 线程池 (IO Threads)

    Note over Main: 事件循环开始 (Event Loop)
    Clients->>Main: 1. 发送写请求 (多路复用监听就绪)
    Main->>Main: 2. 将就绪客户端放入等待读取队列
    
    Main->>IOs: 3. 分配任务 (RR 轮询策略)
    activate IOs
    IOs->>IOs: 4. 并行读取 Socket 并解析命令 (Parse)
    deactivate IOs
    IOs-->>Main: 5. 解析完成 (主线程忙等待同步点)
    
    Note over Main: 核心加锁/串行区
    Main->>Main: 6. 顺序执行所有已解析的命令 (EXEC)
    Note over Main: 数据已在内存更新
    
    Main->>IOs: 7. 分配回写任务
    activate IOs
    IOs->>Clients: 8. 并行将 Response 写回客户端
    deactivate IOs
    
    Note over Main: 清理状态，进入下一轮循环

```


3. 核心机制总结
阶段性同步：主线程在每个步骤（读、写）都会等待所有 IO 线程完成后才继续下一步，这种 “走走停停” 的设计确保了命令执行的顺序性。
写请求处理：对于你提到的多个写请求，它们会被 IO 线程并行解析，但在步骤 6 中，主线程会像单线程版本一样，逐条执行这些写操作，确保内存数据的线程安全。
性能提升：虽然执行还是单线程，但由于网络 IO（往往占总耗时的 50% 以上）被分担了，Redis 6.0 的吞吐量在多核机器上通常能提升 2 倍以上。
