# 虚函数表

> 从虚函数表的概念、实现、对象内存布局、单继承/多继承/虚继承的差异、相关细节(thunk、RTTI、构造/析构中的行为、性能、优化)等方面介绍

## 虚函数表

1. 一种编译器编译器是心啊运行时多态的一种常见机制。  
2. 对于声明了虚函数的类，编译器通常为该类生成一个表，表中保存了只想类的虚函数实现(函数指针)的地址
3. 每个对象通常又一个执行该类 vtable 的指针，叫 vptr(vtable pointer)。通过对象的 vptr 在运行时能调用正确的重写方法，实现动态绑定(runtime dispatch)


> 虚函数表（vtable / vptr）机制、多重继承下的内存布局、RTTI（运行时类型识别）





测试代码
```cpp
#include <iostream>
#include <typeinfo>

struct A {
    int a = 1;
    virtual void fa() { std::cout << "A::fa, a=" << a << "\n"; }
    virtual ~A() {}
};

struct B {
    int b = 2;
    virtual void fb() { std::cout << "B::fb, b=" << b << "\n"; }
    virtual ~B() {}
};

struct C : public A, public B {
    int c = 3;
    void fa() override { std::cout << "C::fa, c=" << c << "\n"; }
    void fb() override { std::cout << "C::fb, c=" << c << "\n"; }
    virtual void fc() { std::cout << "C::fc, c=" << c << "\n"; }
};

int main() {
    C obj;
    A* pa = &obj;
    B* pb = &obj;
    C* pc = &obj;

    std::cout << "== Addresses ==\n";
    std::cout << "Address of obj: " << &obj << "\n";
    std::cout << "A* pa: " << pa << "\n";
    std::cout << "B* pb: " << pb << "\n";
    std::cout << "C* pc: " << pc << "\n";

    std::cout << "\n== Virtual Calls ==\n";
    pa->fa();   // dynamic dispatch
    pb->fb();
    pc->fc();

    std::cout << "\n== RTTI Type Info ==\n";
    std::cout << "typeid(*pa): " << typeid(*pa).name() << "\n";
    std::cout << "typeid(*pb): " << typeid(*pb).name() << "\n";
    std::cout << "typeid(*pc): " << typeid(*pc).name() << "\n";

    return 0;
}


```

```shell
g++ -O0 -g vtable_test.cpp -o vtable_test

nm -C vtable_test | grep vtable

nm -C vtable_test | grep typeinfo

objdump -s -j .rodata vtable_test | less

objdump -C -t vtable_test | grep vtable

gdb ./vtable_test

break main
run
next 20

(gdb) print &obj
$1 = (C *) 0x7fffffffe190
(gdb) x/4gx &obj


x/4gx 0x4040d8


info symbol 0x4011c0


(gdb) info symbol 0x403f80


```


